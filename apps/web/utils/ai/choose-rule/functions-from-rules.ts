import { Function } from "ai";
import { actionFunctionDefs } from "@/utils/ai/actions";
import { REQUIRES_MORE_INFO } from "@/utils/ai/choose-rule/consts";
import { isDefined, RuleWithActions } from "@/utils/types";

type FunctionWithDescription = Function & { description: string };

// This finds the properties that must be generated by the AI.
// NOTE: if two actions with the same type require ai args generation, the AI will only add one of the actions to the function.
// For example, if there are two "Draft email" actions, the AI will only add one of them to the function.
// TODO should be able to fix this with draft_email, draft_email_2, etc.
export function getFunctionsFromRules({ rules }: { rules: RuleWithActions[] }) {
  const rulesWithFunctions = rules.map((rule, i) => {
    // find the properties that must be generated by the AI
    const functionForArgsProperties = Object.fromEntries(
      rule.actions
        .map((action) => {
          const {
            labelPrompt,
            subjectPrompt,
            contentPrompt,
            toPrompt,
            ccPrompt,
            bccPrompt,
          } = action;

          const properties = [
            typeof labelPrompt === "string"
              ? { key: "label", value: labelPrompt }
              : null,
            typeof subjectPrompt === "string"
              ? { key: "subject", value: subjectPrompt }
              : null,
            typeof contentPrompt === "string"
              ? { key: "content", value: contentPrompt }
              : null,
            typeof toPrompt === "string"
              ? { key: "to", value: toPrompt }
              : null,
            typeof ccPrompt === "string"
              ? { key: "cc", value: ccPrompt }
              : null,
            typeof bccPrompt === "string"
              ? { key: "bcc", value: bccPrompt }
              : null,
          ].filter(isDefined);

          // no fields need to be AI generated
          if (!properties.length) return;

          return [
            // key
            action.type,
            // value
            {
              type: "object",
              properties,
              required: actionFunctionDefs[
                action.type
              ].parameters.required.filter((requiredKey) =>
                properties.some((property) => property.key === requiredKey),
              ),
            },
          ];
        })
        .filter(isDefined),
    );

    return {
      rule,
      function: {
        name: `rule_${i + 1}`,
        description: rule.instructions,
        parameters: {},
      } as FunctionWithDescription,
      shouldAiGenerateArgs: Object.keys(functionForArgsProperties).length > 0,
      functionForArgs: {
        name: "handle_email",
        description: "Handle the email.",
        parameters: {
          type: "object",
          properties: functionForArgsProperties,
          required: rule.actions
            .map((action) => action.type)
            // filter out properties that do not exist in the functionForArgsProperties
            .filter((t) => functionForArgsProperties[t]),
        },
      } as FunctionWithDescription,
    };
  });

  rulesWithFunctions.push({
    rule: {} as any,
    shouldAiGenerateArgs: false,
    function: {
      name: REQUIRES_MORE_INFO,
      description: "Request more information to handle the email.",
      parameters: {
        type: "object",
        properties: {},
        required: [],
      },
    } as FunctionWithDescription,
    functionForArgs: {} as FunctionWithDescription,
  });

  return rulesWithFunctions;
}
